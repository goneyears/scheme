#lang scheme
(define (average a b)
  (/ (+ a b) 2))
(define (close-enough? a b)
  (< (abs (- a b)) 0.000001))
(define (abs x)
  (if (< x 0) (- x) x))
(define (square x)
  (* x x))
(define (exp base n)
  (cond ((= n 0) 1)
        ((even? n) (square (exp base (/ n 2))))
        ((odd? n) (* base (exp base (- n 1))))))
(define (search f neg-point pos-point)
  (let ((mid-point (average neg-point pos-point)))
    (if (close-enough? neg-point pos-point) mid-point
        (let ((test-value (f mid-point)))
          (cond ((< test-value 0) (search f mid-point pos-point))
                ((> test-value 0) (search f neg-point mid-point))
                (else mid-point))))))
(define (f1 x)
  (+ x 2))
;(search f1 -10.0 19)
(define (half-find f a b)
  (let ((value-a (f a))
        (value-b (f b)))
   (cond ((and (< value-a 0) (> value-b 0)) (search f a b))
         ((and (< value-b 0) (> value-a 0)) (search f b a))
         (else (error "values are not of opposite sign" a b)))))
;(half-find f1 10 -10)

(define (fixed-point f guess)
  (if (close-enough? (f guess) guess) (f guess)
      (fixed-point f (f guess))))
(define (f2 x)
  (* x x))
(define (fixed-point-2 f guess)
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? next guess) next
          (try next))))
  (try guess))
        
(define (sqrt x)
  (fixed-point (lambda (y) (average y (/ x y))) 1.0))
;(sqrt 4)
(define (fi)
  (fixed-point (lambda (x) (+ 1 (/ 1 x))) 1.0))

(define (ans36)
  (fixed-point (lambda (x) (/ (log 1000) (log x))) 2))

(define (cont-frac n d k)
  (define (cont i)
    (if (= i k) (/ (n k) (d k))
        (/ (n i) (+ (d i) (cont (+ i 1))))))
  (cont 1))
(/ 1 (cont-frac (lambda (i) 1.0) (lambda (i) 1.0) 10))